/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImageCaptions
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  captionRegex: ""
};
var CaptionSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Advanced settings").setHeading();
    new import_obsidian.Setting(containerEl).setName("Caption regex").setDesc("For advanced caption parsing, you can add a regex here. The first capturing group will be used as the image caption. This is useful in situations where you might have another plugin or theme adding text to the caption area which you want to strip out. The placeholder example would be used to exclude everything following a pipe character (if one exists).").addText((text) => text.setPlaceholder("^([^|]+)").setValue(this.plugin.settings.captionRegex).onChange(async (value) => {
      this.plugin.settings.captionRegex = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/main.ts
var ImageCaptions = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.figureGridProcessor = (source, el, ctx) => {
      const container = el.createDiv({ cls: "columnGrid" });
      const wikilinks = this.extractWikilinks(source);
      const promises = wikilinks.map((wikilink) => {
        return this.processGridImageSync(wikilink, container, ctx.sourcePath);
      });
      Promise.all(promises);
    };
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new CaptionSettingTab(this.app, this));
    this.registerMarkdownCodeBlockProcessor(
      "columnGrid",
      this.figureGridProcessor.bind(this)
    );
    this.registerMarkdownPostProcessor(this.externalImageProcessor());
    this.addEditOnClickToGrids();
    this.observer = new MutationObserver((mutations) => {
      mutations.forEach((rec) => {
        if (rec.type === "childList") {
          this.processChildListChanges(rec);
        }
        if (rec.type === "attributes" && rec.target instanceof HTMLElement) {
          this.processAttributeChanges(rec);
        }
      });
    });
    this.observer.observe(document.body, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["alt", "src"]
    });
  }
  processChildListChanges(rec) {
    rec.target.querySelectorAll(".image-embed, .video-embed, .internal-embed").forEach(async (embedContainer) => {
      var _a;
      const img = embedContainer.querySelector("img, video");
      if (!img) return;
      const altText = embedContainer.getAttribute("alt") || "";
      const parsedAlt = this.parseAltAttributes(altText);
      if (parsedAlt.caption) {
        embedContainer.setAttribute("alt", parsedAlt.caption);
      }
      const figure = embedContainer.querySelector("figure");
      const figCaption = embedContainer.querySelector("figcaption");
      if (figure || ((_a = img.parentElement) == null ? void 0 : _a.nodeName) === "FIGURE") {
        if (figCaption && parsedAlt.caption) {
          const children = await this.renderMarkdown(parsedAlt.caption, "");
          figCaption.replaceChildren(...children);
        }
      } else if (parsedAlt.caption && parsedAlt.caption !== embedContainer.getAttribute("src")) {
        await this.insertFigureWithCaption(img, embedContainer, parsedAlt, "");
      }
    });
  }
  processAttributeChanges(rec) {
    const target = rec.target;
    if (target.classList.contains("internal-embed") && rec.attributeName === "alt") {
      const altText = target.getAttribute("alt") || "";
      const parsedAlt = this.parseAltAttributes(altText);
      const img = target.querySelector("img, video");
      if (img) {
        const parentFigure = img.closest("figure");
        if (parentFigure && parsedAlt.class.length > 0) {
          parentFigure.classList.value = "figure";
          parsedAlt.class.forEach((cls) => parentFigure.classList.add(cls));
        }
      }
    }
    if ((target.tagName === "IMG" || target.tagName === "VIDEO") && (rec.attributeName === "alt" || rec.attributeName === "src")) {
      setTimeout(async () => {
        const parent = target.parentElement;
        if (parent && parent.nodeName === "FIGURE") {
          const figCaption = parent.querySelector("figcaption");
          const parsedData = this.parseImageData(target);
          if (figCaption && parsedData.caption) {
            const children = await this.renderMarkdown(parsedData.caption, "");
            figCaption.replaceChildren(...children);
          }
        }
      }, 10);
    }
  }
  parseAltAttributes(altText) {
    const result = {
      caption: "",
      class: [],
      width: void 0
    };
    if (!altText) return result;
    const parts = altText.split("|").map((part) => part.trim());
    for (const part of parts) {
      if (part.includes(":")) {
        const [key, ...valueParts] = part.split(":");
        const value = valueParts.join(":").trim();
        switch (key.toLowerCase()) {
          case "caption":
            result.caption = value;
            break;
          case "class":
            result.class = value.split(",").map((cls) => cls.trim());
            break;
          case "width":
            result.width = value;
            break;
        }
      } else {
        if (!result.caption) {
          result.caption = part;
        }
      }
    }
    return result;
  }
  parseImageData(img) {
    const altText = img.getAttribute("alt") || "";
    return this.parseAltAttributes(altText);
  }
  async insertFigureWithCaption(imageEl, outerEl, parsedData, sourcePath) {
    let container;
    if (parsedData.caption) {
      imageEl.setAttribute("alt", parsedData.caption);
    } else {
      imageEl.removeAttribute("alt");
    }
    container = outerEl.createEl("figure");
    container.addClass("figure");
    if (parsedData.class && parsedData.class.length > 0) {
      parsedData.class.forEach((cls) => container.addClass(cls));
    }
    container.appendChild(imageEl);
    if (parsedData.caption) {
      const figcaption = container.createEl("figcaption", {
        cls: "figcaption"
      });
      const children = await this.renderMarkdown(parsedData.caption, sourcePath);
      figcaption.replaceChildren(...children);
    }
  }
  async insertFigureWithCaptionSync(imageEl, outerEl, parsedData, sourcePath) {
    let container;
    if (parsedData.caption) {
      imageEl.setAttribute("alt", parsedData.caption);
    } else {
      imageEl.removeAttribute("alt");
    }
    container = outerEl.createEl("figure");
    container.addClass("figure");
    if (parsedData.class && parsedData.class.length > 0) {
      parsedData.class.forEach((cls) => container.addClass(cls));
    }
    container.appendChild(imageEl);
    if (parsedData.caption) {
      const figcaption = container.createEl("figcaption", {
        cls: "figcaption"
      });
      const children = await this.renderMarkdown(parsedData.caption, sourcePath);
      if (children.length === 1 && children[0] instanceof HTMLParagraphElement) {
        const pElement = children[0];
        figcaption.replaceChildren(...Array.from(pElement.childNodes));
      } else {
        figcaption.replaceChildren(...children);
      }
    }
  }
  extractWikilinks(source) {
    const wikilinks = [];
    let current = "";
    let inWikilink = false;
    let bracketCount = 0;
    for (let i = 0; i < source.length; i++) {
      const char = source[i];
      const nextChar = source[i + 1];
      if (char === "!" && nextChar === "[") {
        inWikilink = true;
        current = "![";
        bracketCount = 1;
        i += 1;
      } else if (inWikilink) {
        current += char;
        if (char === "[") {
          bracketCount++;
        } else if (char === "]") {
          bracketCount--;
          if (bracketCount === 0) {
            wikilinks.push(current);
            current = "";
            inWikilink = false;
          }
        }
      }
    }
    return wikilinks;
  }
  async processGridImageSync(imageSyntax, container, sourcePath) {
    const cleanSyntax = imageSyntax.replace(/\s+/g, " ").trim();
    const match = cleanSyntax.match(/!\[\[([^\|\]]+?)(?:\|([^\]]*?))?\]\]/);
    if (!match) return;
    const imagePath = match[1].trim();
    const params = match[2] || "";
    const abstractFile = this.app.metadataCache.getFirstLinkpathDest(imagePath, sourcePath);
    if (!abstractFile) {
      console.warn(`Fichier introuvable : ${imagePath}`);
      return;
    }
    const resolvedPath = this.app.vault.getResourcePath(abstractFile);
    const img = container.createEl("img");
    img.src = resolvedPath;
    img.setAttribute("alt", params);
    const parsedData = this.parseAltAttributes(params);
    await this.insertFigureWithCaptionSync(img, container, parsedData, sourcePath);
  }
  addEditOnClickToGrids() {
    document.addEventListener("click", (event) => {
      var _a;
      const target = event.target;
      const gridContainer = target.closest(".columnGrid");
      if (gridContainer) {
        let editButton = (_a = gridContainer.parentElement) == null ? void 0 : _a.querySelector(".edit-block-button");
        if (!editButton) {
          let parent = gridContainer.parentElement;
          while (parent && !editButton) {
            editButton = parent.querySelector(".edit-block-button");
            parent = parent.parentElement;
          }
        }
        if (editButton) {
          editButton.click();
          event.preventDefault();
          event.stopPropagation();
        }
      }
    });
  }
  externalImageProcessor() {
    return (el, ctx) => {
      el.findAll("img:not(.emoji), video").forEach(async (img) => {
        const altText = img.getAttribute("alt") || "";
        const parsedData = this.parseAltAttributes(altText);
        const parent = img.parentElement;
        if (parent && parent.nodeName !== "FIGURE" && parsedData.caption && parsedData.caption !== img.getAttribute("src")) {
          await this.insertFigureWithCaption(img, parent, parsedData, ctx.sourcePath);
        }
      });
    };
  }
  async renderMarkdown(markdown, sourcePath) {
    const el = createDiv();
    await import_obsidian2.MarkdownRenderer.renderMarkdown(markdown, el, sourcePath, this);
    const nodes = [];
    for (const child of el.childNodes) {
      nodes.push(child);
    }
    return nodes.length > 0 ? nodes : [document.createTextNode(markdown)];
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onunload() {
    this.observer.disconnect();
  }
};
