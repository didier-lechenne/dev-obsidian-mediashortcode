/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImageCaptions,
  renderMarkdown: () => renderMarkdown
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  captionRegex: ""
};
var CaptionSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Advanced settings").setHeading();
    new import_obsidian.Setting(containerEl).setName("Caption regex").setDesc("For advanced caption parsing, you can add a regex here. The first capturing group will be used as the image caption. This is useful in situations where you might have another plugin or theme adding text to the caption area which you want to strip out. The placeholder example would be used to exclude everything following a pipe character (if one exists).").addText((text) => text.setPlaceholder("^([^|]+)").setValue(this.plugin.settings.captionRegex).onChange(async (value) => {
      this.plugin.settings.captionRegex = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/main.ts
var filenamePlaceholder = "%";
var filenameExtensionPlaceholder = "%.%";
var ImageCaptions = class extends import_obsidian2.Plugin {
  async onload() {
    this.registerMarkdownPostProcessor(
      this.externalImageProcessor()
    );
    await this.loadSettings();
    this.addSettingTab(new CaptionSettingTab(this.app, this));
    this.observer = new MutationObserver((mutations) => {
      mutations.forEach((rec) => {
        if (rec.type === "childList") {
          rec.target.querySelectorAll(".figure-grid-container").forEach(async (container) => {
            this.processGridContainer(container);
          });
          rec.target.querySelectorAll("img:not(.emoji), video").forEach(async (img) => {
            const parent = img.parentElement;
            if (parent && !parent.closest(".figure-grid-container") && !img.closest("figure")) {
              await this.processStandaloneImage(img);
            }
          });
        }
      });
    });
    this.observer.observe(document.body, {
      subtree: true,
      childList: true
    });
  }
  async processGridContainer(container) {
    const images = container.querySelectorAll("img:not(.emoji), video");
    images.forEach(async (img) => {
      const parsedData = this.parseImageData(img);
      if (!img.closest("figure") && !img.closest(".imagenote")) {
        await this.createFigureInGrid(img, parsedData);
      }
    });
  }
  async createFigureInGrid(imageEl, parsedData) {
    var _a, _b, _c, _d;
    const container = imageEl.parentElement;
    if (!container) return;
    let figure;
    if (parsedData.dataNom === "imagenote") {
      figure = container.createEl("span", { cls: "imagenote" });
      figure.setAttribute("id", parsedData.id);
      figure.setAttribute("data-src", imageEl.getAttribute("src") || "");
      if (((_a = parsedData.class) == null ? void 0 : _a.length) > 0) {
        parsedData.class.forEach((cls) => figure.addClass(cls));
      }
      container.replaceChild(figure, imageEl);
      figure.appendChild(imageEl);
      if (parsedData.caption) {
        const captionSpan = figure.createEl("span", { cls: "caption" });
        const children = (_b = await renderMarkdown(parsedData.caption, "", this)) != null ? _b : [parsedData.caption];
        captionSpan.replaceChildren(...children);
      }
    } else {
      figure = container.createEl("figure", { cls: "figure" });
      figure.setAttribute("data-nom", parsedData.dataNom);
      figure.setAttribute("id", parsedData.id);
      if (((_c = parsedData.class) == null ? void 0 : _c.length) > 0) {
        parsedData.class.forEach((cls) => figure.addClass(cls));
      }
      const style = [];
      if (parsedData.width) style.push(`--width: ${parsedData.width}`);
      if (parsedData.printwidth) style.push(`--print-width: ${parsedData.printwidth}`);
      if (parsedData.col) style.push(`--col: ${parsedData.col}`);
      if (parsedData.printcol) style.push(`--print-col: ${parsedData.printcol}`);
      if (parsedData.imgX) style.push(`--img-x: ${parsedData.imgX}`);
      if (parsedData.imgY) style.push(`--img-y: ${parsedData.imgY}`);
      if (parsedData.imgW) style.push(`--img-w: ${parsedData.imgW}`);
      if (style.length > 0) {
        figure.setAttribute("style", style.join("; "));
      }
      container.replaceChild(figure, imageEl);
      figure.appendChild(imageEl);
      if (parsedData.caption) {
        const children = (_d = await renderMarkdown(parsedData.caption, "", this)) != null ? _d : [parsedData.caption];
        figure.createEl("figcaption", { cls: "figcaption" }).replaceChildren(...children);
      }
    }
  }
  externalImageProcessor() {
    return (el, ctx) => {
      this.createGridContainers(el);
      el.findAll("img:not(.emoji), video").forEach(async (img) => {
        if (!img.closest(".figure-grid-container")) {
          await this.processStandaloneImage(img);
        }
      });
    };
  }
  createGridContainers(container) {
    const images = Array.from(container.querySelectorAll("img:not(.emoji), video"));
    let currentGroup = [];
    let allGroups = [];
    for (let i = 0; i < images.length; i++) {
      const img = images[i];
      const parsedData = this.parseImageData(img);
      if (parsedData.caption || parsedData.dataNom !== "image" || parsedData.width || parsedData.class.length > 0) {
        currentGroup.push(img);
      } else {
        if (currentGroup.length > 0) {
          allGroups.push([...currentGroup]);
          currentGroup = [];
        }
      }
    }
    if (currentGroup.length > 0) {
      allGroups.push(currentGroup);
    }
    allGroups.forEach((group) => {
      if (group.length > 0) {
        const firstImg = group[0];
        const parent = firstImg.parentElement;
        if (!parent) return;
        const gridContainer = parent.createEl("div", { cls: "figure-grid-container" });
        parent.insertBefore(gridContainer, firstImg);
        group.forEach((img) => {
          gridContainer.appendChild(img);
        });
      }
    });
  }
  async processStandaloneImage(img) {
    const parsedData = this.parseImageData(img);
    const parent = img.parentElement;
    if (parent && (parsedData.caption || parsedData.dataNom !== "image") && !img.closest("figure") && !img.closest(".imagenote")) {
      const gridContainer = parent.createEl("div", { cls: "figure-grid-container" });
      parent.insertBefore(gridContainer, img);
      gridContainer.appendChild(img);
      await this.createFigureInGrid(img, parsedData);
    }
  }
  parseImageData(img) {
    let altText = img.getAttribute("alt") || "";
    const src = img.getAttribute("src") || "";
    const parts = altText.split("|").map((part) => part.trim());
    const result = {
      dataNom: "image",
      caption: "",
      width: void 0,
      printwidth: void 0,
      col: void 0,
      printcol: void 0,
      class: [],
      poster: void 0,
      imgX: void 0,
      imgY: void 0,
      imgW: void 0,
      id: this.generateSlug(src)
    };
    const edge = altText.replace(/ > /, "#");
    if (altText === src || edge === src) {
      result.caption = "";
      return result;
    }
    if (parts.length > 1 && ["imagenote", "image", "imageGrid", "figure", "video"].includes(parts[0])) {
      result.dataNom = parts[0];
      for (let i = 1; i < parts.length; i++) {
        const part = parts[i];
        if (part.includes(":")) {
          const [key, ...valueParts] = part.split(":");
          const value = valueParts.join(":").trim();
          switch (key.toLowerCase()) {
            case "caption":
              result.caption = value;
              break;
            case "width":
              result.width = value;
              break;
            case "printwidth":
              result.printwidth = value;
              break;
            case "col":
              result.col = value;
              break;
            case "printcol":
              result.printcol = value;
              break;
            case "class":
              result.class = value.split(",").map((c) => c.trim());
              break;
            case "poster":
              result.poster = value;
              break;
            case "imgx":
              result.imgX = value;
              break;
            case "imgy":
              result.imgY = value;
              break;
            case "imgw":
              result.imgW = value;
              break;
            case "id":
              result.id = value;
              break;
          }
        }
      }
    } else {
      result.caption = parts[0];
    }
    if (this.settings.captionRegex && result.caption) {
      try {
        const match = result.caption.match(new RegExp(this.settings.captionRegex));
        result.caption = (match == null ? void 0 : match[1]) || "";
      } catch (e) {
      }
    }
    if (result.caption === filenamePlaceholder) {
      const match = src.match(/[^\\/]+(?=\.\w+$)|[^\\/]+$/);
      result.caption = (match == null ? void 0 : match[0]) || "";
    } else if (result.caption === filenameExtensionPlaceholder) {
      const match = src.match(/[^\\/]+$/);
      result.caption = (match == null ? void 0 : match[0]) || "";
    } else if (result.caption === "\\" + filenamePlaceholder) {
      result.caption = filenamePlaceholder;
    }
    result.caption = result.caption.replace(/<<(.*?)>>/g, (_, linktext) => "[[" + linktext + "]]");
    return result;
  }
  generateSlug(src) {
    const filename = src.split("/").pop() || src;
    const nameWithoutExt = filename.replace(/\.[^.]+$/, "");
    return nameWithoutExt.toLowerCase().replace(/[^a-z0-9]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
  }
  getCaptionText(img) {
    const parsedData = this.parseImageData(img);
    return parsedData.caption;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onunload() {
    this.observer.disconnect();
  }
};
async function renderMarkdown(markdown, sourcePath, component) {
  const el = createDiv();
  await import_obsidian2.MarkdownRenderer.renderMarkdown(markdown, el, sourcePath, component);
  for (const child of el.children) {
    if (child.tagName.toLowerCase() === "p") {
      return child.childNodes;
    }
  }
}
